# MultiThreadedHarryPotter

All fourteen players of two teams, four balls and two goal posts will be represented by pthreads and will communicate with each other via signals. Pointers to pthread_t objects representing these pthreads will be stored in appropriately named global variables.

Two pthreads representing two Bludgers will spend most of their time sleeping. Once in a while, a Bludger will wake up, randomly pick one of 14 players and send it a SIGINT signal. Receipt of a SIGINT by a player pthread is assumed to be a hit from a Bludger. When a player pthread receives a hit from a Bludger (i.e. it receives a SIGINT signal), she will fall off her broomstick and hence exit the game UNLESS it receives a SIGUSR1 signal within 2 seconds (or some other suitable time duration) of receiving a SIGINT. Receipt of a SIGUSR1 signal by a player pthread is considered as a Beater intercepting the Bludger. A Beater pthread essentially performs an infinite loop where in each iteration it randomly selects a teammate still around (possibly herself), sends this teammate a SIGUSR1 (guessing that the teammate is hit by a Bludger) and goes to sleep for some random short time duration.

The pthread representing the Quaffle also performs an infinite loop where in each iteration it randomly picks a Chaser and sends it a SIGUSR2 signal. The receipt of a SIGUSR2 signal by a Chaser means that this Chaser is in possession of the Quaffle. The Chaser then sends a SIGINT signal to the pthread representing the opponent's goal post, which indicates an attempt to score a goal. The Keeper pthread can prevent this goal by sending its goal post a SIGUSR1 signal within 2 seconds of the goal post receiving the SIGINT signal. For this reason, each Keeper pthread executes an infinite loop where in each iteration it sends a SIGUSR1 signal to her goal post (to prevent any goal attempt) and then goes to sleep for a small random time duration. If a goal does happen (i.e. no SIGUSR1 signal is received by the goal post pthread within 2 seconds of receiving a SIGINT goal attempt), the goal post pthread increases by 10 points the global variable indicating the the opponent team's score.

The pthread representing the Golden Snitch periodically wakes up, toggles the value of a global boolean flag "Caught_Snitch" and then goes back to sleep. Each Seeker pthread periodically wakes up and checks the value of "Caught_Snitch". If the value is true, the Seeker adds 150 points to her team score, prints the final scores of both teams and calls exit() to terminate the simulation. If the value is false, the Seeker goes back to sleep. The simulation should also terminate if the last player falls off the broom. All the pthreads should print informative messages (also containing the current team scores) whenever any event occurs (e.g. a Bludger targeting a player, the player falling off the broom, a goal scored/prevented, catching of the Snitch etc.). You can decide any reasonable values for different sleep durations.

You can use the sleep() call (http://man7.org/linux/man-pages/man3/sleep.3.html) to make a thread go to sleep for specified number of seconds.

PS: In order to compile your code with gcc, you would need to include the flag -lpthread:

gcc hw7.c -o quidditch -lpthread
